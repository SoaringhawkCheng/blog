---
title: 「Head First设计模式」学习笔记
catalog: true
date: 2019-05-24 19:44:46
subtitle:
header-img:
tags:
- software
categories:
- 编程
---
> 书籍豆瓣链接：[《Head First设计模式》](https://book.douban.com/subject/2243615/)
> 
> 开始学习时间：5-24
> 
> 预计完成时间：6-9
> 
> 实际完成时间：

# 设计基础

* 继承

		通过扩展一个已有的类，并继承改类的属性和行为，来创建一个新的类
		
* 封装

		封装就是把抽象的数据和对数据进行的操作封装在一起，数据被保存在内部，程序的其他部分只有通过被授权的操作（成员方法）才能对数据进行操作。

* 多态

		在判断引用对象的实际类型，根据其实际的类型调用相应的方法。分为静多态(编译时多态)和动多态(运行时多态)
		
* 抽象

		定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型
		
* UML图图示
![](https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/head-first-design-pattern/1.jpg?raw=true)

* 抽象类和接口

		【抽象类】
		抽象方法只作声明、而不包含实现
		不能被实例化
		接口不能被实例化
		接口只能包含方法声明
		具体派生类必须覆盖基类的抽象方法
		抽象派生类可以覆盖基类的抽象方法，如果不覆盖，则其具体派生类必须覆盖它们
		【接口】
		接口不能被实例化
		接口只能包含方法声明
		接口的成员包括方法、属性、索引器和事件
		接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员
		【相同点】
		都可以被继承
		都不能被实例化
		都可以包含方法声明
		派生类必须实现未实现的方法
		【不同点】
		抽象类可以有构造方法，接口中不能有构造方法
		抽象类中可以有普通成员变量，接口中没有普通成员变量
		抽象类中可以包含静态方法，接口中不能包含静态方法
		一个类可以实现多个接口，但只能继承一个抽象类
		接口可以被多重实现，抽象类只能被单一继承
		抽象类实现接口，可以把接口中方法映射到抽象类中作为抽象方法，而不是实现
		
# 设计原则

* 将应用中可能变化之处，把他们独立出来

		将会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分

* 针对接口编程，而不是针对实现编程
	
		通过接口来调用一个类及其方法，而不是直接建立类实体来调用类

* 多用组合，少用继承

		组合的意思就是把你需要的东西组合在一个类里面，这个类并不需要继承任何父类，也可以提供想要的行为方法。利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。利用组合(composition)和委托(delegation)的做法扩展对象的可以在运行时动态地进行扩展。
		
* 未来交互对象之间的松耦合设计而努力

		松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低

* 开放-关闭原则 类应该对扩展开发，对修改封闭

		我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求
		
* 依赖倒置原则

		要依赖抽象，不要依赖具体的类


# 设计模式

* 策略模式

		定义算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于使用算法的客户
		
* 观察者模式

		定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
		
* 装饰者模式

		继承的问题：类数量爆炸，设计死板，以及基类加入的新功能并不适用于所有的子类
		装饰器动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案
		利用继承达到“类型匹配”，而不是利用继承获得“行为”，行为来自装饰者和基础组件，或与其他装饰者之间的组合关系
		
* 工厂方法模式

		定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。
		简单工厂把全部的事情在一个地方处理完了，工厂方法确实创建一个框架，让子类决定要如何实现。比如说，在工厂方法中，orderPizza方法提供了一般的框架，以便创建比萨，orderPizza方法依赖工厂方法创建具体的类，并制造出实际的比萨。简单工厂的做法，可以将对象的创建封装起来，但是简单工厂不具备工厂方法的弹性，不能变更正在创建的产品。