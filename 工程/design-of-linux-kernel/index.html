<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          「Linux内核设计与实现&amp;深入理解Linux内核」学习笔记 - 沙罗双树园 | 追寻梦之碎片
        
    </title>

    <link rel="canonical" href="https://blog.soaringhawkcheng.tech/工程/design-of-linux-kernel/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">


    
<link rel="stylesheet" href="/css/donate.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/vintage/article.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#os" title="os">os</a>
                            
                        </div>
                        <h1>「Linux内核设计与实现&amp;深入理解Linux内核」学习笔记</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 追寻梦之碎片 on
                            2020-05-01
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">沙罗双树园</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>书籍豆瓣链接：<br>
<a target="_blank" rel="noopener" href="https://book.douban.com/subject/6097773/">《Linux内核设计与实现》</a><br>
<a target="_blank" rel="noopener" href="https://book.douban.com/subject/2287506/">《深入理解Linux内核》</a></p>
<p>相关书籍链接：<br>
<a target="_blank" rel="noopener" href="https://book.douban.com/subject/24708145/">《Linux内核设计的艺术》</a><br>
<a target="_blank" rel="noopener" href="https://book.douban.com/subject/4843567/">《深入Linux内核架构》</a></p>
<p>开始学习时间：</p>
<p>预计完成时间：</p>
<p>实际完成时间：</p>
</blockquote>
<h2><span id="绪论">绪论</span></h2>
<h3><span id="内核结构">内核结构</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/os-architecture.png?raw=true" alt></p>
<p>GNU C库，提供了链接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制</p>
<p>linux内核分三层：</p>
<ol>
<li>系统调用接口</li>
<li>独立于体系结构的内核代码</li>
<li>依赖于体系结构的代码</li>
</ol>
<p>内核子系统：</p>
<ol>
<li>进程管理</li>
<li>内存管理</li>
<li>虚拟文件系统</li>
<li>网络栈</li>
<li>设备驱动器</li>
</ol>
<h3><span id="特性">特性</span></h3>
<h4><span id="单内核微内核">单内核微内核</span></h4>
<ol>
<li>单内核</li>
</ol>
<p>将内核整体上作为单独的大过程实现，运行在一个单独的地址空间</p>
<ol start="2">
<li>微内核</li>
</ol>
<p>划分为多个独立的过程，运行在各自的地址空间上，使用IPC通信</p>
<h4><span id="linux内核特性">Linux内核特性</span></h4>
<ol>
<li>支持动态加载内核模块</li>
<li>支持对称多处理(SMP)，各处理器共享内存子系统以及总线结构</li>
<li>可以抢占</li>
<li>不区分线程进程</li>
</ol>
<h3><span id="内核开发的准备">内核开发的准备</span></h3>
<p>开发内核代码与开发用户代码的差异</p>
<ol>
<li>
<p>无标准C库</p>
</li>
<li>
<p>必须使用GNU C</p>
<p>内联函数 将性能要求高，代码长度短的函数定义为内联</p>
<p>内联汇编 使用C语言和汇编混编，偏底层或执行时间严格，一般使用汇编</p>
</li>
<li>
<p>没有内存保护，不分页</p>
</li>
<li>
<p>内核栈小而固定，2页(64位2*16k)</p>
</li>
<li>
<p>同步和并发</p>
<p>内核支持异步中断，SMP和抢占，容易产生竞争条件</p>
</li>
</ol>
<h2><span id="内存寻址">内存寻址</span></h2>
<h3><span id="用户空间和内核空间">用户空间和内核空间</span></h3>
<h4><span id="地址空间划分">地址空间划分</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/address-space.png?raw=true" alt></p>
<p>内核地址空间存放的是内核代码和数据</p>
<p>用户空间存放的是用户程序的代码和数据</p>
<p>Linux使用两级保护机制: 0级供内核使用，3级供用户使用</p>
<h4><span id="地址映射模型">地址映射模型</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/mmu.png?raw=true" alt></p>
<p>IOMMU，IO管理单元，作用是连接DMA-capable I/O总线（Direct Memory Access-capable I/O Bus）和主存（main memory），IOMMU将设备访问的虚拟地址转化为物理地址</p>
<p>DMA(direct memory access)，直接存储器访问，传输将数据从一个地址空间复制到另外一个地址空间。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实行和完成</p>
<p>MMU，内存管理单元，是负责处理CPU的内存访问请求的计算机请求，功能包括虚拟地址到物理地址转换</p>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/address-mapping.png?raw=true" alt></p>
<p>进程代码中的地址是逻辑地址，经过全局描述符表GDT映射为线性地址，经过TLB和PTE映射为物理地址</p>
<h4><span id="进程执行状态">进程执行状态</span></h4>
<ol>
<li>用户态 进程执行用户程序代码</li>
</ol>
<p>CPU在特权级别最低(3级)的用户代码中运行。当进程被中断程序中断时，中断处理程序使用当前进程的内核栈，进程可以象征性地称为处于进程的内核态</p>
<ol start="2">
<li>内核态 进程执行系统调用陷入内核代码中执行</li>
</ol>
<p>CPU在特权等级最高(0级)的内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈</p>
<h3><span id="上下文">上下文</span></h3>
<h4><span id="cpu状态">CPU状态</span></h4>
<ol>
<li>运行于用户空间，执行用户线程</li>
<li>运行于内核空间，处理进程上下文(系统调用，陷阱)</li>
<li>运行于内核空间，处于中断上下文(同步中断&amp;异步中断)</li>
</ol>
<h4><span id="进程上下文">进程上下文</span></h4>
<p>用户进程需要传递给内核的参数，以及内核需要保存的一整套变量和寄存器的值和当时的环境。进程的上下文可以分为三个部分：</p>
<ol>
<li>用户级上下文 代码，数据，用户堆栈以及共享存储区</li>
<li>寄存器上下文 通用寄存器，程序寄存器IP，处理器状态寄存器EFLAGS，栈指针ESP</li>
<li>系统级上下文 进程控制块task_struct，内存管理信息(mm_struct, vm_area_struct, pgd, pte)，内核栈</li>
</ol>
<h4><span id="中断上下文">中断上下文</span></h4>
<p>硬件通过触发信号，导致内核根据IDT(中断描述符表)调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。</p>
<p>可以看作硬件传递过来的参数以及内核需要保存的一些其他环境(当前)</p>
<h2><span id="进程管理">进程管理</span></h2>
<h3><span id="进程结构">进程结构</span></h3>
<h4><span id="进程任务队列">进程任务队列</span></h4>
<p>task_list 任务队列 双向循环链表 节点类型是task_struct</p>
<p>task_struct 进程描述符 包含进程信息</p>
<h4><span id="进程描述符">进程描述符</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/kernel-stack.png?raw=true" alt></p>
<p>进程的thread_info和内核栈放在连续的两页框中，thread_info中的task域存放的是指向task struct的指针</p>
<p>task_struct包含的进程信息：打开的文件，进程地址空间，挂起的信号，进程的状态</p>
<p>task struct成员：</p>
<ol>
<li>parent指针 指向父进程task_struct</li>
<li>state 进程状态</li>
</ol>
<h4><span id="描述符存放">描述符存放</span></h4>
<p>内核使用唯一的值pid标志每个进程</p>
<p>内核中大部分处理进程的代码都是直接通过task_struct进行</p>
<p>通过current宏查找当前正在运行进程的task_struct</p>
<h4><span id="进程状态">进程状态</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/process-state.png?raw=true" alt></p>
<h4><span id="进程家族树">进程家族树</span></h4>
<p>Linux下有三个特殊的进程idle进程（PID=0），init进程（PID=1），和kthreadd（PID=2）</p>
<ul>
<li>
<p>idle进程由系统自动创建，运行在内核态</p>
<p>idle进程其pid=0，其前身是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换。</p>
<p>这个进程只干一件事情：向CPU发送HLT（halt）指令，告诉CPU现在没有需要它处理的程序，CPU可以进入空闲状态</p>
<p>这个进程的优先级是整个系统中最低的，只要还有其它进程需要使用CPU，它就会暂停下来停止执行，等其它进程使用完CPU，操作系统就会切换回这个System Idle进程，继续向CPU发送HLT指令</p>
<p>对于多个CPU，单个CPU多个核心或者多CPU多核心的系统，System Idle会有N个线程，其中N为整个系统的总核心数。</p>
</li>
<li>
<p>kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间，负责所有内核进程的调度和管理。</p>
<p>它的任务就是管理和调度其他内核线程kernel_thread, 会循环执行一个kthread的函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程</p>
</li>
<li>
<p>init进程由idle通过kernel_thread创建，在内核空间完成初始化后，加载init程序</p>
<p>在这里我们就主要讲解下init进程，init进程由0进程创建，完成系统的初始化，是系统中所有其他用户进程的祖先进程</p>
<p>Linux中的所有进程都是由init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成后，init将变成为守护进程监视系统其他进程。</p>
<p>所以说init进程是Linux系统操作中不可缺少的程序之一，如果内核找不到init进程就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。</p>
</li>
</ul>
<h3><span id="进程创建">进程创建</span></h3>
<p>分为两步：fork和exec</p>
<h4><span id="fork">fork</span></h4>
<p>fork拷贝当前进程创建子进程，或者共享地址空间，使用写时拷贝</p>
<p>子进程和父进程的区别在于，PID PPID和某些资源统计量(挂起的信号)</p>
<p>fork的实际开销：复制父进程页表，给子进程创建进程描述符</p>
<p>linux通过系统调用clone实现fork，clone(SIGCHLD, 0)</p>
<p>fork步骤：</p>
<ol>
<li>创建内核栈，thread_info和task_struct，值和当前进程完全相同</li>
<li>清空或设置task struct中的一些值，比如state</li>
<li>更新flags</li>
<li>分配pid</li>
<li>拷贝或共享：打开的文件信息，文件系统信息，信号处理函数，进程地址空间，命名空间等</li>
</ol>
<h4><span id="vfork">vfork</span></h4>
<p>vfork不拷贝页表项，子进程先运行，clone(CLONE_VFORK|CLONE_VM|SIGCHLD, 0)</p>
<h4><span id="exec">exec</span></h4>
<p>读取可执行文件并将其载入地址空间开始运行</p>
<h3><span id="线程在linux中的实现">线程在Linux中的实现</span></h3>
<p>线程仅仅被视为一个与其他进程共享某个资源的进程</p>
<h4><span id="创建线程">创建线程</span></h4>
<p>clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND, 0)</p>
<h4><span id="内核线程">内核线程</span></h4>
<p>内核线程没有独立的地址空间，它们只能在内核空间运行</p>
<h3><span id="进程终结">进程终结</span></h3>
<p>进程析构发生在显示或者隐式调用exit时</p>
<p>析构的重要动作：</p>
<ol>
<li>所有与进程相关联的资源被释放</li>
<li>向父进程发送信号，给子进程找养父，进程状态设为EXIT_ZOMBIE状态</li>
<li>schedule切换到新的进程</li>
<li>仍占用的内存：内核栈，thread_info和task_struct，目的是给父进程提供信息</li>
<li>父进程检索到子进程信息后，剩余内存被释放</li>
</ol>
<h4><span id="孤儿进程">孤儿进程</span></h4>
<p>父进程在子进程前退出，给子进程在当前进程组找一个线程作为父亲，或者是init</p>
<p>init进程会调用wait，清除所有相关的僵死进程</p>
<h2><span id="进程调度">进程调度</span></h2>
<p>进程调度程序，可看作在可运行进程之间，分配有限的处理器时间资源的内核子系统</p>
<h3><span id="多任务">多任务</span></h3>
<h4><span id="抢占式多任务">抢占式多任务</span></h4>
<p>由调度程序决定什么时候停止一个进程运行，以便其他进程得到执行机会</p>
<p><strong>抢占</strong> 调度程序的强制挂起动作</p>
<h4><span id="非抢占式多任务">非抢占式多任务</span></h4>
<p>除非进程自己主动停止运行，否则它会一直执行</p>
<p><strong>让步</strong> 进程主动挂起自己</p>
<h3><span id="调度策略">调度策略</span></h3>
<h4><span id="io密集和cpu密集型进程">IO密集和CPU密集型进程</span></h4>
<p><strong>IO密集</strong> 进程大部分时间提交IO请求或等待IO请求，IO指任何类型的可阻塞资源</p>
<p><strong>CPU密集</strong> 进程大部分时间在执行代码</p>
<p>调度策略要兼顾：进程响应速度，最大系统利用率</p>
<p>Linux为保证交互式应用和桌面系统性能，更倾向于优先调度IO密集进程</p>
<h4><span id="进程优先级">进程优先级</span></h4>
<p>两种不同的优先级范围：</p>
<ol>
<li>nice值 -20~19 优先级越来越低</li>
<li>实时优先级 0~99 优先级越来越高</li>
</ol>
<h4><span id="时间片">时间片</span></h4>
<p>预先设置好的，进程被抢占之前能够运行的时间</p>
<h3><span id="调度算法">调度算法</span></h3>
<p>Linux内核有两个调度类：CFS和实时调度类</p>
<h4><span id="公平调度">公平调度</span></h4>
<p>CFS不分配时间片给进程</p>
<p>CFS将nice值作为进程获得处理器运行比的权重</p>
<p>基于所有可运行进程的计算进程运行多久</p>
<p>允许每个进程运行一段时间，循环轮转，选择运行最少的进程调度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">下面举个直观的例子来说明：</span><br><span class="line">假设系统中只有3个进程ProcessA(NI&#x3D;+10)，ProcessB(NI&#x3D;0)，ProcessC(NI&#x3D;-10)，NI表示进程的nice值，时间片&#x3D;10ms</span><br><span class="line">1) 调度前，把进程优先级按一定的权重映射成时间片(这里假设优先级高一级相当于多5msCPU时间)。</span><br><span class="line">    假设ProcessA分配了一个时间片10ms，那么ProcessB的优先级比ProcessA高10(nice值越小优先级越高)，ProcessB应该分配10*5+10&#x3D;60ms，以此类推，ProcessC分配20*5+10&#x3D;110ms</span><br><span class="line">2) 开始调度时，优先调度分配CPU时间多的进程。由于ProcessA(10ms),ProcessB(60ms),ProcessC(110ms)。显然先调度ProcessC</span><br><span class="line">3) 10ms(一个时间片)后，再次调度时，ProcessA(10ms),ProcessB(60ms),ProcessC(100ms)。ProcessC刚运行了10ms，所以变成100ms。此时仍然先调度ProcessC</span><br><span class="line">4) 再调度4次后(4个时间片)，ProcessA(10ms),ProcessB(60ms),ProcessC(60ms)。此时ProcessB和ProcessC的CPU时间一样，这时得看ProcessB和ProcessC谁在CPU运行队列的前面，假设ProcessB在前面，则调度ProcessB</span><br><span class="line">5) 10ms(一个时间片)后，ProcessA(10ms),ProcessB(50ms),ProcessC(60ms)。再次调度ProcessC</span><br><span class="line">6) ProcessB和ProcessC交替运行，直至ProcessA(10ms),ProcessB(10ms),ProcessC(10ms)。</span><br><span class="line">    这时得看ProcessA，ProcessB，ProcessC谁在CPU运行队列的前面就先调度谁。这里假设调度ProcessA</span><br><span class="line">7) 10ms(一个时间片)后，ProcessA(时间片用完后退出),ProcessB(10ms),ProcessC(10ms)。</span><br><span class="line">8) 再过2个时间片，ProcessB和ProcessC也运行完退出。</span><br><span class="line"></span><br><span class="line">这个例子很简单，主要是为了说明调度的原理，实际的调度算法虽然不会这么简单，但是基本的实现原理也是类似的：</span><br><span class="line">1）确定每个进程能占用多少CPU时间(这里确定CPU时间的算法有很多，根据不同的需求会不一样)</span><br><span class="line">2）占用CPU时间多的先运行</span><br><span class="line">3）运行完后，扣除运行进程的CPU时间，再回到 1）</span><br></pre></td></tr></table></figure>
<h4><span id="实时调度">实时调度</span></h4>
<p>linux提供两种实时调度策略：SCHED_FIFO和SCHED_RR，比普通非实时的调度策略SCHED_NORMAL具有更高优先级</p>
<p>SCHED_FIFO 不使用时间片，处于可执行会一直执行，直到阻塞或显示释放</p>
<p>SCHED_RR 带时间片的SCHED_FIFO</p>
<h3><span id="调度实现">调度实现</span></h3>
<h4><span id="时间记账">时间记账</span></h4>
<p>CFS没有时间片的概念，需要维护进程运行的时间记账sched_entity，嵌入在task_struct中</p>
<p>sched_entity中的vruntime，存放进程的虚拟运行时间，vruntime并不是实际的运行时间，它是实际运行时间进行加权运算后的结果</p>
<h4><span id="算法步骤">算法步骤</span></h4>
<ol>
<li>计算每个进程的vruntime，通过update_curr()函数更新进程的vruntime</li>
<li>选择具有最小vruntime的进程投入运行。</li>
<li>进程运行完后，更新进程的vruntime，转入步骤2)</li>
</ol>
<h4><span id="进程管理">进程管理</span></h4>
<p>可运行队列 使用红黑树，存放可执行进程，迅速找到最小的vruntime值的进程</p>
<p>等待队列 简单链表，存放休眠(被阻塞)进程</p>
<h3><span id="抢占和上下文切换">抢占和上下文切换</span></h3>
<p><strong>上下文切换</strong>即从一个可执行进程切换到另一个可执行进程，每个进程包含一个need_resched标志</p>
<h4><span id="用户抢占">用户抢占</span></h4>
<p>内核即将返回用户空间，如果need resched被设置，会导致schedule被调用，此时会发生用户抢占</p>
<p>用户抢占在以下情况产生：</p>
<ol>
<li>系统调用返回用户空间</li>
<li>从中断处理程序返回用户空间</li>
</ol>
<h4><span id="内核抢占">内核抢占</span></h4>
<p>在一个内核态运行的进程，可能在执行内核函数期间被另一个进程取代</p>
<p>内核抢占的满足条件：</p>
<ol>
<li>没持有锁(preempt_count)</li>
<li>内核代码可重入(因为内核支持SMP)</li>
</ol>
<p>内核抢占在以下情况发生：</p>
<ol>
<li>中断处理正在执行，且返回内核空间之前，隐式调用schedule</li>
<li>内核代码再一次具有抢占性，如解锁等</li>
<li>内核任务显示调用schedule</li>
<li>内核任务阻塞，导致需要调用schedule</li>
</ol>
<h2><span id="系统调用">系统调用</span></h2>
<p>系统调用使用软中断实现：通过引发一个异常来促使系统切换到内核态执行系统调用处理程序</p>
<h3><span id="意义">意义</span></h3>
<p>系统调用的存在，有以下重要的意义:</p>
<p>1）用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发。</p>
<pre><code>比如：用户程序通过write()系统调用就可以将数据写入文件，而不必关心文件是在磁盘上还是软盘上，或者其他存储上。
</code></pre>
<p>2）系统调用使得用户程序有更好的可移植性。</p>
<pre><code>只要操作系统提供的系统调用接口相同，用户程序就可在不用修改的情况下，从一个系统迁移到另一个操作系统。
</code></pre>
<p>3）系统调用使得内核能更好的管理用户程序，增强了系统的稳定性。</p>
<pre><code>因为系统调用是内核实现的，内核通过系统调用来控制开放什么功能及什么权限给用户程序。

这样可以避免用户程序不正确的使用硬件设备，从而破坏了其他程序。
</code></pre>
<p>4）系统调用有效的分离了用户程序和内核的开发。</p>
<pre><code>用户程序只需关心系统调用API，通过这些API来开发自己的应用，不用关心API的具体实现。

内核则只要关心系统调用API的实现，而不必管它们是被如何调用的。
</code></pre>
<h2><span id="内核数据结构">内核数据结构</span></h2>
<h2><span id="中断和中断处理">中断和中断处理</span></h2>
<h2><span id="中断下半部">中断下半部</span></h2>
<h2><span id="内核同步介绍">内核同步介绍</span></h2>
<p>同步：识别出异常处理、中断处理、可延迟函数、内核线程中的临界区，采用适当的保护措施，以确保在任意时刻只有一个内核控制路径处于临界区。<br>
      如果是但CPU系统，可以采取访问共享数据结构时关闭中断的方式实现临界区，因为只有在开中断的情况下，才能发生内核控制路径的嵌套。<br>
      但是在多处理器系统中，许多CPU可能同时执行内核路径，不能假设只要禁止内核抢占功能，而且中断、异常和软中断处理程序都没有访问过该数据结构，就能保证这个数据结构能够安全地访问。</p>
<p>一、内核抢占<br>
内核抢占:如果进程执行内核函数时（内核态运行），允许发生内核切换。<br>
使用内核抢占的目的：减少用户态进程的分派延迟（dispatch latency），即从进程变为可执行状态到它实际开始运行之间的时间间隔。<br>
二、同步原语<br>
    Linux内核有多种内核同步技术：每CPU变量(Per-CPU),原子操作、内存屏障、自旋锁、信号量、顺序锁、本地中断禁止、本地软中断（可延迟函数）禁止、读-拷贝-更新（RCU）<br>
   1）Per-CPU（每CPU）变量<br>
    总的原则:内核控制路径应该在禁用抢占的情况下访问Per-CPU变量。<br>
    2）原子操作<br>
     “读 - 修改 -  写”类型：若干汇编语言指令都是这种类型，访问存储器单元两次，第一次读原值，第二次写新值。<br>
    存储器仲裁器：对访问RAM芯片的操作进行串行化的硬件电路。<br>
     避免由于“读 - 修改 -  写”类型引起竞争的方法:确保这样的操作在芯片级是原子的。避免其他CPU访问同一存储单元。<br>
    3）优化和内存屏障<br>
    (1)编译器优化，用barrier（）优化屏障  防止<br>
    (2)CPU取指优化，用 wmb/rmb等防止<br>
   优化屏障（optimization barrier)：barrier()宏， 原语保证编译程序不会混淆 原语之前 的汇编语言指令 和 原语之后 的汇编语言指令。<br>
   内存屏障(memory barrier)：保证原语之后 的操作 一定要在 原语之前的操作已经完成后 才执行。Pentium4引入lfence、sfence、mfence等汇编指令，有效的实现 读内存屏障、写内存屏障 和读-写内存屏障。<br>
   asm volatile(“lfence”) 等同于<br>
   asm volatile(&quot;lock; addl $0, 0(%%esp)”::”memory”)<br>
    lock使得这条指令成为CPU的一个内存屏障。<br>
   4）自旋锁<br>
     自旋锁：如果内核控制路径发现锁由运行在另一个CPU的内核控制路径”锁着“，就在当前CPU”旋转“，反复执行一条紧凑的循环指令，直到锁被释放。<br>
   一般来说：自旋锁所保护的每个临界区都是禁止内核抢占的。但是分为：具有内核抢占的spin_lock宏；非抢占式内核中的spin_lock宏。<br>
     spin_unlock宏:   movb $1,slp-&gt;slock<br>
    5)读/写自旋锁<br>
    读/写自旋锁：允许多个内核控制路径 同时 读 同一个数据结构；如果一个内核控制路径想对这个结构进行写操作，那么它必须首先获得 读/写锁的 写锁，写锁 独占访问这个资源。<br>
    6)顺序锁(seqlock)<br>
     顺序锁(seqlock):读者正在读的时候也允许写者继续运行，读者需要反复多次（读之前一次 读完之后一次 读取一个标志位，每个读者都必须在读数据前后两次读顺序计数器[seqlock_t中sequence字段],写者通过write_seqlock(){是sequence加1}和write_sequnlock()获取和释放锁）相同的数据直到它获得有效的副本。类似 读/写自旋锁， 为 写者 赋予了较高的优先级。<br>
   7）RCU（读-拷贝-更新）<br>
    RCU（读-拷贝-更新）:保护被多个CPU 读 的数据结构而设计的同步技术。写者更新数据结构时，它间接引用指针并生成整个数据结构的副本；写者修改这个副本；一旦修改完，写者改变指向数据结构的指针（需要使用内存屏障 来保证，只有数据结构被修改后，已更新的指针对其他CPU才是可见的。其中内存屏障一种方法：自旋锁和RCU结合 禁止写者的并发执行），写者必须在读者执行完rcu_read_unlock()之后，才可以释放旧副本。<br>
    a)RCU只保护被动态分配并通过指针引用的数据结构；b)在被RCU保护的临界区中，任何内核控制路径都不能睡眠。<br>
     静止状态（quiescent state),CPU经历以下一种状态即为静止状态：<br>
     a）CPU执行进程切换<br>
     b）CPU开始在用户态执行<br>
     c）CPU执行空循环<br>
     写者调用call_rcu()释放旧副本.当所有CPU都通过quiescent state之后，call_rcu()接受rcu_head描述符的地址和将要调用的回调函数的地址作为参数。回调函数执行，写者释放数据结构的旧副本。<br>
     内核没经过一个时钟滴答，就周期性检查本地CPU是否进经过了一个quiescent state。<br>
   8）信号量<br>
   9）读/写信号量<br>
   10)补充原语<br>
   11)禁止本地中断<br>
   12）禁止和激活可延迟函数<br>
三、避免竞争条件<br>
   1）引用计数器<br>
   2）大内核锁<br>
每个进程描述符都含有lock_depth字段，允许同一个进程几次获取大内核锁。</p>
<h2><span id="定时器和时间管理">定时器和时间管理</span></h2>
<h2><span id="内存管理">内存管理</span></h2>
<h3><span id="内存管理结构">内存管理结构</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/uma.png?raw=true" alt></p>
<p>现代计算机的内存组织形式包括UMA和NUMA，其中UMA中所有cpu访问内存的速度都一样快，而在NUMA系统中，每个cpu访问不同内存的速度并不一样。通常，NUMA计算机每个cpu都有自己的本地内存，各个cpu不仅可以访问自己的本地内存，也可以访问其它cpu的内存，但是访问本地内存的速度最快，访问其它cpu内存的速度依其与本cpu的距离增加而依次减慢。</p>
<h4><span id="内存管理单位">内存管理单位</span></h4>
<p><strong>mem_mmap</strong>内核全局变量，包含系统中所有的物理内存对应的page数组</p>
<p>Linux对内存的管理划分成三个层次，分别是Node、Zone、Page。对这三个层次简介如下：<br>
<img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/mem-tree.png?raw=true" alt></p>
<table>
<thead>
<tr>
<th>层次</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node(节点)</td>
<td>CPU被划分成多个节点，每个节点都有自己的一块内存，可以参考NUMA架构有关节点的介绍</td>
</tr>
<tr>
<td>Zone(区)</td>
<td>每一个Node（节点）中的内存被划分成多个管理区域（Zone），用于表示不同范围的内存</td>
</tr>
<tr>
<td>Page(页)</td>
<td>每一个管理区又进一步被划分为多个页面，页面是内存管理中最基础的分配单位</td>
</tr>
</tbody>
</table>
<h4><span id="物理内存分区">物理内存分区</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/physical-zone.jpg?raw=true" alt></p>
<p>内核把物理内存划分为不同的区：</p>
<table>
<thead>
<tr>
<th>区</th>
<th>描述</th>
<th>物理内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt;16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>16~896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt;896MB</td>
</tr>
</tbody>
</table>
<h4><span id="内存分区介绍">内存分区介绍</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/virtual-zone-mapping.jpg?raw=true" alt></p>
<ul>
<li>低端内存</li>
</ul>
<p>包含ZONE_DMA和ZONE_NORMAL，</p>
<p>ZONE_DMA的范围是0~16M，该区域的物理页面专门供I/O设备的DMA使用。之所以需要单独管理DMA的物理页面，是因为DMA使用物理地址访问内存，不经过MMU，并且需要连续的缓冲区，所以为了能够提供物理上连续的缓冲区，必须从物理地址空间专门划分一段区域用于DMA。</p>
<p>由于ZONE_NORMAL和内核线性空间存在直接映射关系，所以内核会将频繁使用的数据如kernel代码、GDT、IDT、PGD(page global directory)、mem_map数组等放在ZONE_NORMAL里</p>
<ul>
<li>高端内存</li>
</ul>
<p>高端内存包含ZONE_HIGHMEM，在x86体系结构中，这个区的内存不能映射到内核地址空间上，也就是<strong>没有逻辑地址</strong>。将用户数据、页表(PT)等不常用数据放在ZONE_ HIGHMEM里，只在要访问这些数据时才建立映射关系(kmap())</p>
<h3><span id="内核地址空间">内核地址空间</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/kernel-virtual-zone.jpg?raw=true" alt></p>
<h4><span id="直接映射空间page_offset~vmalloc_start">直接映射空间(PAGE_OFFSET~VMALLOC_START)</span></h4>
<p>物理地址 = 逻辑地址 – 0xC0000000</p>
<p>kmalloc和__get_free_page()分配的是这里的页面，二者是借助slab分配器，直接分配物理页再转换为逻辑地址（物理地址连续）。适合分配小段内存。</p>
<p>此区域包含了内核镜像、物理页框表mem_map，内核代码区，内核数据区，GDT，IDT，PGD等资源。</p>
<h4><span id="动态映射空间vmalloc_start~vmalloc_end">动态映射空间(VMALLOC_START~VMALLOC_END)</span></h4>
<p>内核通过调用vmalloc这个区域获得内存</p>
<h4><span id="永久映射空间pkmap_base~fixaddr_start">永久映射空间(PKMAP_BASE~FIXADDR_START)</span></h4>
<p>通过kmap，建立永久映射</p>
<h4><span id="临时映射空间fixaddr_start~fixaddr_top">临时映射空间(FIXADDR_START~FIXADDR_TOP)</span></h4>
<p>内核在FIXADDR_START到FIXADDR_TOP之间保留了一些线性空间用于特殊需求，称为固定映射空间</p>
<p>在这个空间中，有一部分用于高端内存的临时映射，这块空间由如下特点：</p>
<ol>
<li>每个CPU占用一块空间</li>
<li>每个CPU占用的空间，又分为多个小空间，每个小空间是1个page，用于一个目的</li>
</ol>
<p>当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过 kmap_atomic() 可实现临时映射。</p>
<h3><span id="进程地址空间">进程地址空间</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/process-space.jpg?raw=true" alt></p>
<h3><span id="内存分配系统">内存分配系统</span></h3>
<h4><span id="伙伴系统页分配">伙伴系统(页分配)</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/buddy.gif?raw=true" alt></p>
<p>实际应用中，经常需要分配一组连续的页框，而频繁地申请和释放不同大小的连续页框，必然导致在已分配页框的内存块中分散了许多小块的空闲页框。这样，即使这些页框是空闲的，其他需要分配连续页框的应用也很难得到满足。</p>
<p>为了避免出现这种情况，Linux内核中引入了伙伴系统算法(buddy system)。伙伴系统（buddy system）是以页为单位管理和分配内存。</p>
<p>管理区zone上的free_area域，把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。每个页框块的第一个页框的物理地址是该块大小的整数倍。</p>
<h4><span id="slab分配层">slab分配层</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/slab.png?raw=true" alt><br>
<img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/kmem-cache.gif?raw=true" alt></p>
<p>slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢</p>
<p>而slab分配器是基于对象进行管理的，相同类型的对象归为一类。slab层按不同的对象划分为高速缓存组，每种对象类型对应一个高速缓存kmem_cache</p>
<p>高速缓存kmem_cache被划分为slab，slab由一个或多个物理上连续的页组成，每个高速缓存有三个slab链表，full，partial，empty</p>
<h3><span id="内存分配方式">内存分配方式</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/mem-alloc.jpg?raw=true" alt></p>
<h4><span id="kmalloc">kmalloc</span></h4>
<p>调用伙伴系统的get_free_page从ZONE_NORMAL分配，分配的线性和物理地址连续。一般用于分配小块内存(一般不超过128k)，kmalloc分配方式基于slab</p>
<h4><span id="vmalloc">vmalloc</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vmalloc.png?raw=true" alt><br>
<img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vmalloc.jpg?raw=true" alt></p>
<p>优先使用ZONE_HIGHMEM，当内存不够才分配ZONE_NORMAL。分配的物理地址不连续；一般分配大内存，需要页表。vmalloc分配的物理页不会被交换出去</p>
<p>每次调用vmalloc()在内核成功申请一段连续虚拟内存后，都会对应一个vm_struct子区域。使用全局变量<strong>vmlist</strong>指向vm_struct链表</p>
<h4><span id="kmap">kmap</span></h4>
<p>略</p>
<h3><span id="内存分配维度">内存分配维度</span></h3>
<h4><span id="按进程分配">按进程分配</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/interrupt-stack.png?raw=true" alt><br>
内核栈 每个进程都有1-2页固定大小的内核栈</p>
<p>中断栈 中断栈为每个进程提供了一个用于中断处理程序的栈，中断处理程序不用再和被中断进程共享一个内核栈，对每个进程仅仅耗费了一页</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726">各种栈介绍</a></p>
<h4><span id="按cpu数据分配">按CPU数据分配</span></h4>
<p>略</p>
<h2><span id="虚拟文件系统">虚拟文件系统</span></h2>
<h3><span id="文件系统抽象层">文件系统抽象层</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vfs-architecture.png?raw=true" alt></p>
<p>虚拟文件系统(VFS)是linux内核和存储设备之间的抽象层，主要有以下好处。</p>
<ol>
<li>简化了应用程序的开发：应用通过统一的系统调用访问各种存储介质</li>
<li>简化了新文件系统加入内核的过程：新文件系统只要实现VFS的各个接口即可，不需要修改内核部分</li>
</ol>
<h3><span id="unix文件">UNIX文件</span></h3>
<p>UNIX文件系统的一些概念</p>
<ol>
<li>安装点 文件系统被安装在安装点上，在全局层次结构中被称为命名空间</li>
<li>文件 文件数据</li>
<li>索引节点 文件元数据</li>
<li>目录项 VFS把目录项当做文件一样看待</li>
<li>超级块 存放文件系统信息</li>
</ol>
<h3><span id="vfs对象和数据结构">VFS对象和数据结构</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vfs-obj.png?raw=true" alt><br>
<img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vfs-obj-mapping.png?raw=true" alt><br>
VFS主要有4个对象类型：</p>
<ol>
<li>超级块对象 代表一个具体的已安装文件系统</li>
<li>索引节点对象 代表一个具体文件</li>
<li>目录项对象 代表一个目录项，是路径组成部分</li>
<li>文件对象 代表进程打开的文件</li>
</ol>
<h4><span id="超级块对象">超级块对象</span></h4>
<p>主要存储文件系统相关的信息，包括inode与block的总量、使用量、剩余量等</p>
<p>通常对应存储在磁盘的特定扇区中的文件系统超级块或文件系统控制块，但是对于那些基于内存的文件系统(比如proc,sysfs)，超级块是在使用时创建在内存中的</p>
<h4><span id="索引节点对象">索引节点对象</span></h4>
<p>一个索引节点代表文件系统中的一个文件，它可以是设备或管道这样的特殊文件</p>
<p>索引节点仅当被文件访问时，才在内存中创建</p>
<h4><span id="目录项对象">目录项对象</span></h4>
<p>目录项没有没有对应磁盘数据结构，使用内存高速缓存(slab)。VFS根据字符串形式的路径名现场创建它，由于目录项对象并非真正保存在磁盘上，所以目录项结构体没有是否被修改的标志。路径/bin/vi中/,bin和vi都是目录项，前两个是目录，最后一个是普通文件</p>
<p>目录项状态</p>
<ol>
<li>被使用：对应一个有效的索引节点，并且该对象由一个或多个使用者</li>
<li>未使用：对应一个有效的索引节点，但是VFS当前并没有使用这个目录项</li>
<li>负状态：没有对应的有效索引节点（可能索引节点被删除或者路径不存在了）</li>
</ol>
<p>目录项缓存</p>
<ol>
<li>已使用目录链表</li>
<li>最近被使用目录双向链表，用于缓存</li>
<li>散列表，快速定位</li>
</ol>
<h4><span id="文件对象">文件对象</span></h4>
<p>只存在于内存中，是已打开文件在内存中的表示，反过来指向目录项</p>
<h4><span id="文件系统相关数据结构">文件系统相关数据结构</span></h4>
<p>file_system_type 描述文件系统类型</p>
<p>vfsmount 描述一个安装文件系统的实例</p>
<p>每种文件系统，不管有多少个实例安装到系统中，都只有一个file_system_type</p>
<h4><span id="进程相关数据结构">进程相关数据结构</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vfs-object.gif?raw=true" alt><br>
<img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/prosess-file.gif?raw=true" alt></p>
<p>file_struct task_struct-&gt;files目录项指向，打开的文件及文件描述符</p>
<p>fs_struct task_struct-&gt;fs域指向，文件系统和进程相关的信息，包含了进程的当前目录和根目录</p>
<p>namespace task_struct-&gt;mmt_namespace指向，命名空间，所有进程共享同样的命名空间，只有在进行clone()操作时使用CLONE_NEWS标志，才会给进程一个唯一的命名空间结构体拷贝</p>
<h3><span id="文件系统结构">文件系统结构</span></h3>
<h4><span id="磁盘结构">磁盘结构</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/fs-structure.png?raw=true" alt><br>
MBR： 主引导分区。</p>
<p>自举块（引导分区Boot Sector）：分区中文件系统自身引导程序存放的地方。</p>
<p>超级块（Super block）： 记录整个文件系统相关的信息的地方，它记录的信息主要有：block与inode的总量、使用量、剩余量，文件系统的挂载时间，最近一次写入数据的时间等。</p>
<p>柱面组（块组） 每个柱面为一个柱面组（组号与柱面号一致），一个分区包含多个柱面。</p>
<p>配置信息：不详。</p>
<p>i节点位图（inode bitmap）：每个inode结点对应位图中的一个位（这样一个字节可表示8个inode的使用情况），每个位值为0或1，表示该位所处下标对应的inode有没有被使用。</p>
<p>块位图（block bitmap）：每个数据块或目录块都对应着块位图中的一个位，位的下标和块编号一一对应，每个位的值为0或1，表示该块是否已被使用。</p>
<p>i节点表（数组）（inode table）：每个文件或者目录都有对应的一个inode，inode放在inode table中，包括inode的编号及其对应的信息。</p>
<p>i节点（inode）： 存储文件相关信息（不包括文件名）。</p>
<p>数据块（data block）： 存储文件具体内容。</p>
<p>目录块： 特殊一点的数据块，存放inode编号–文件（目录）名。</p>
<h4><span id="三级间接寻址">三级间接寻址</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/3-level-inode.png?raw=true" alt></p>
<p>文件系统通过三级间接寻址的方式来提高文件大小的上限。块大小若以1 block计算，文件大小的上限为16G，若以4 block为块大小，那文件大小的上限超过了1T；ext4文件系统中，数据指针有256B，那文件大小上限就非常大了；</p>
<h4><span id="数据块存储内容">数据块存储内容</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/data-block-structure.png?raw=true" alt></p>
<p>数据块中存储的是一条一条的记录项，每条记录项都由文件名、inode编号、记录长度(该记录项首地址到下一条记录项的首地址的长度)。每一个记录项就是该目录下“ls -a”的结果</p>
<h4><span id="普通文件结构">普通文件结构</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/file-structure.png?raw=true" alt></p>
<h4><span id="目录文件结构">目录文件结构</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/entry-structure.png?raw=true" alt></p>
<h2><span id="块io层">块I/O层</span></h2>
<h3><span id="块设备简介">块设备简介</span></h3>
<p>I/O设备主要有2类:</p>
<ol>
<li>字符设备 只能顺序读写设备中的内容，比如 串口设备，键盘</li>
<li>块设备 能够随机读写设备中的内容，比如 硬盘，U盘</li>
</ol>
<h4><span id="扇区">扇区</span></h4>
<p>物理上的最小寻址单元</p>
<p><strong>原子性问题</strong>操作系统与磁盘的数据交换单位是扇区。一次操作，是写一个扇区大小(512b)的数据。如果写入数据小于一个扇区，只需要无缓冲的写入到磁盘。磁盘特性保证，这种情况可以原子地写入磁盘</p>
<h4><span id="块">块</span></h4>
<p>逻辑上的最小寻址单元，内核执行的所有磁盘操作都是按照块进行的</p>
<p>块的大小一般是扇区整数倍，并且小于等于页的大小</p>
<h3><span id="内核访问块设备方法">内核访问块设备方法</span></h3>
<p>内核通过文件系统访问块设备时，需要先把块读入到内存中。所以文件系统为了管理块设备，必须管理块和内存页之间的映射。</p>
<p>内核中有2种方法来管理块和内存页之间的映射。</p>
<ol>
<li>缓冲区和缓冲区头</li>
<li>bio</li>
</ol>
<h4><span id="缓冲区buffer-cache">缓冲区buffer cache</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/page-block.png?raw=true" alt></p>
<p>每个块都是一个缓冲区，同时对每个块都定义一个缓冲区头来描述它。</p>
<p>由于块的大小是小于内存页的大小的，所以每个内存页会包含一个或者多个块</p>
<p>2.6内核中将两者合并到了一起，使buffer_head只存储buffer-block的映射信息，不再存储block的内容</p>
<p>用缓冲区头来管理内核的 I/O 操作主要存在以下2个弊端:</p>
<ol>
<li>对内核而言，操作内存页是最为简便和高效的。而且每个块对应一个缓冲区头，导致内存的利用率降低</li>
<li>每个缓冲区头只能表示一个块，所以内核在处理大数据时，会分解为对一个个小的块的操作，造成不必要的负担和空间浪费</li>
</ol>
<h4><span id="bio">bio</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/bio.png?raw=true" alt></p>
<p>目前，块IO操作的基本容器由bio结构体表示</p>
<p>bio结构体的出现就是为了改善上面缓冲区头的2个弊端，它表示了一次 I/O 操作所涉及到的所有内存页。</p>
<p>bio相当于在缓冲区上又封装了一层，使得内核在 I/O操作时只要针对一个或多个内存页即可，不用再去管理磁盘块的部分。</p>
<p>使用bio结构体还有以下好处：</p>
<ol>
<li>bio结构体很容易处理高端内存，因为它处理的是内存页而不是直接指针</li>
<li>bio结构体既可以代表普通页I/O，也可以代表直接I/O(指不通过<strong>页高速缓存</strong>的IO操作)</li>
<li>bio结构体便于执行分散-集中（矢量化的）块I/O操作，操作中的数据可以取自多个物理页面</li>
</ol>
<h3><span id="io调度">IO调度</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/page-cache-bio.jpg?raw=true" alt></p>
<p>块设备将它们挂起的快IO请求保存在请求队列reques_queue中，队列中的reques结构体包含多个bio</p>
<h2><span id="进程地址空间">进程地址空间</span></h2>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/process-architecture.gif?raw=true" alt></p>
<h3><span id="内存描述符">内存描述符</span></h3>
<p>内核使用内存描述符结构体mm_struct表示进程的地址空间</p>
<p>进程描述符task_struct结构体中的mm域存放着该进程使用的内存描述符</p>
<h4><span id="分配内存描述符">分配内存描述符</span></h4>
<p>子进程使用allocate_mm从slab缓存中分配得到mm_struct</p>
<p>线程创建，调用clone设置CLONE_VM标志，会共享mm_struct</p>
<h4><span id="撤销内存描述符">撤销内存描述符</span></h4>
<p>mm_struct中的mm_users计数降到零，将调用mmdrop函数</p>
<h4><span id="内核线程">内核线程</span></h4>
<p>内核线程没有进程地址空间，不需要自己的mm_struct</p>
<p>但是内核仍然需要页表，来访问内核空间(高端内存)</p>
<p>故内核的mm为NULL，active_mm为前一个进程的mm_struct</p>
<h3><span id="虚拟内存区域">虚拟内存区域</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/vm-area-struct.png?raw=true" alt></p>
<p>vm_area_struct描述了指定地址空间内连续区间上的一个独立内存范围，比如堆和栈就是一个内存区域</p>
<p>线性区分为匿名映射线性区和文件映射线性区，</p>
<p>内存描述符的mmap域，使用单链表连接所有的内存区域对象vm_area_struct，内存描述符的mm_rb使用红黑树组织所有vm_area_struct</p>
<p>链表适合遍历，红黑树适合用于查找定位</p>
<p>vm_area_struct-&gt;shared 关联address_space-&gt;i_mmap或address_space-&gt;i_mmap_nonlinear</p>
<p>vm_area_struct-&gt;anon_vma_chain 指向匿名线性区立链表头</p>
<p>vm_area_struct-&gt;anon_vma 指向anon_vma，匿名线性区描述符</p>
<h3><span id="内存映射">内存映射</span></h3>
<p>内核使用do_mmap创建一个新的线性区间，用户空间可以通过mmap调用do_mmap</p>
<ol>
<li>匿名映射</li>
<li>文件映射 指定了文件名和偏移量</li>
</ol>
<h4><span id="文件映射">文件映射</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/file-mapping.png?raw=true" alt></p>
<p>address_space用于管理文件映射的页面的结构</p>
<p>address_space-&gt;host域指向所属inode，如果为NULL，表示对应交换区</p>
<p>address_space-&gt;page_tree域是一个包含所有page的radix树，指定文件偏移量offset去page_tree中搜，如果不存在，分配一个page，用于从用户空间拷贝数据，或者从磁盘读入数据</p>
<p>后备文件的共享映射，多个进程的vm_area_struct指向同一个物理内存区域，一个进程对文件内容的修改，会被其他进程可见。对文件内容的修改会被写回到后备文件。</p>
<p>后备文件的私有映射，多个进程的vm_area_struct指向同一个物理内存区域，采用写时拷贝的方式，当一个进程对文件内容做修改，不会被其他进程看到。另外对文件内的修改也不会被写回到后备文件。当内存不够需要进行页回收时，私有映射的页被交换到交换区。一般用在加载共享代码库</p>
<h4><span id="匿名映射">匿名映射</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/anonymous-mapping.png?raw=true" alt></p>
<p>匿名文件的共享映射，内核创建一个初始都是0的物理内存区域，然后多个进程的vm_area_struct指向这个共享的物理内存区域，对该区域内容的修改对所有进程可见。匿名文件在页回收时被交换到交换区</p>
<p>匿名文件的私有映射，内核创建一个初始都是0的物理内存区域，对该区域内容的修改只对创建者进程可见。匿名文件在页回收时被交换到交换区。malloc()底层是用了匿名文件的私有映射来分配大块内存。</p>
<h3><span id="页表">页表</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/pte.png?raw=true" alt><br>
地址空间中的地址都是虚拟内存中的地址，而CPU需要操作的是物理内存，所以需要一个将虚拟地址映射到物理地址的机制。</p>
<p>这个机制就是页表，linux中使用3级页面来完成虚拟地址到物理地址的转换。</p>
<ol>
<li>PGD - 全局页目录，包含一个 pgd_t 类型数组，多数体系结构中 pgd_t 类型就是一个无符号长整型</li>
<li>PMD - 中间页目录，它是个 pmd_t 类型数组</li>
<li>PTE - 简称页表，包含一个 pte_t 类型的页表项，该页表项指向物理页面</li>
</ol>
<p><strong>TLB块表</strong>是一个缓存虚拟地址到物理地址映射的硬件</p>
<h2><span id="页高速缓存">页高速缓存</span></h2>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/read-disk.png?raw=true" alt></p>
<p>页高速缓存是内核所使用的的主要磁盘高速缓存(此外还有inode高速缓存和dentry高速缓存)<br>
几乎所有的文件读写都依赖于页高速缓存，内核开始一个读操作，检查需要的数据是否在页高速缓存中</p>
<ol>
<li>缓存未命中，调度块IO操作从磁盘读取，内核将读来的数据放入页缓存中，以满足用户态进程的读请求</li>
<li>缓存命中，则放弃访问磁盘，直接从内存中读取</li>
</ol>
<h3><span id="缓存页类型">缓存页类型</span></h3>
<p>页高速缓存可能是以下的类型：</p>
<ol>
<li>含有普通文件数据的页</li>
<li>含有目录的页</li>
<li>直接从块设备文件(跳过文件系统层)读出的页</li>
<li>含有用户态进程数据的页，但页中的数据已经被交换到磁盘</li>
<li>属于特殊文件系统的页，如IPC所使用的特殊文件系统shm</li>
</ol>
<p>页高速缓存中的每个页所包含的数据肯定属于某个文件，这个文件称为页的所有者owner</p>
<h3><span id="磁盘io方式">磁盘IO方式</span></h3>
<h4><span id="标准io">标准IO</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/io.png?raw=true" alt></p>
<p>缓存I/O的优点：1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；2）可以减少读盘的次数，从而提高性能</p>
<p>缓存I/O的缺点：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输。数据在传输过程中需要在应用程序地址空间和缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的</p>
<h4><span id="直接io">直接IO</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/directio.png?raw=true" alt></p>
<p>直接 I/O 访问文件方式减少了一次数据拷贝和一些系统调用的耗时，很大程度降低了 CPU 的使用率以及内存的占用</p>
<p>但是直接与磁盘交互非常耗时，所以只有确定标准I/O开销非常巨大才考虑使用直接I/O</p>
<p>通常直接IO与异步IO结合使用，会得到比较好的性能(异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待)</p>
<h4><span id="文件映射">文件映射</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/mmap.png?raw=true" alt></p>
<p>当你映射一个文件时，它的内容不会立即全部放入内存，而是通过页面错误（Page Fault）按需导入。错误处理程序在获得具有所需文件内容的页帧后 将虚拟页映射到页缓存</p>
<p>减少系统调用。我们只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样，而不会出现大量的 read/write 系统调用</p>
<p>减少数据拷贝。普通的 read() 调用，数据需要经过两次拷贝；而 mmap 只需要从磁盘拷贝一次就可以了，并且由于做过内存映射，也不需要再拷贝回用户空间</p>
<p>可靠性高。mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样，可以依靠内核线程定期写回磁盘。但是需要提的是，mmap 在内核崩溃、突然断电的情况下也一样有可能引起内容丢失，当然我们也可以使用 msync来强制同步写</p>
<h3><span id="address_space对象">address_space对象</span></h3>
<p>页缓存的核心数据结构是address_space对象</p>
<p>address_space-&gt;page_tree域是一个包含所有page的radix树</p>
<p>指定文件偏移量offset去page_tree中搜，如果不存在，分配一个page，用于从用户空间拷贝数据，或者从磁盘读入数据</p>
<h3><span id="写缓存策略">写缓存策略</span></h3>
<p>不缓存(nowrite) 也就是不缓存写操作，当对缓存中的数据进行写操作时，直接写入磁盘，同时使此数据的缓存失效</p>
<p>写透缓存(write-through) 写数据时同时更新磁盘和缓存</p>
<p>回写(copy-write or write-behind) 写数据时直接写到缓存，由另外的进程(回写进程)在合适的时候将数据同步到磁盘</p>
<h4><span id="缓存回收策略">缓存回收策略</span></h4>
<p>略</p>
<h2><span id="页框回收">页框回收</span></h2>
<h3><span id="页分类">页分类</span></h3>
<p>首先对页进行分类：不可回收页，可交换页，可同步页，可丢弃页</p>
<table>
<thead>
<tr>
<th>页类型</th>
<th>说明</th>
<th>回收操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可回收页</td>
<td>空闲页<br>保留页<br>内核动态分配页<br>内核堆栈页<br>锁定页</td>
<td>不允许回收</td>
</tr>
<tr>
<td>可交换页</td>
<td>用户态地址空间的匿名映射页<br>tmpfs文件系统的文件映射页</td>
<td>将页的内容保存在交换区</td>
</tr>
<tr>
<td>可同步页</td>
<td>用户态地址空间文件映射页<br>存有磁盘文件数据且在页高速缓存的页<br>块设备缓冲区页<br>某些磁盘高速缓存<br></td>
<td>与磁盘同步</td>
</tr>
<tr>
<td>可丢弃页</td>
<td>内存高速缓存中的未使用页<br>目录项高速缓存未使用页</td>
<td></td>
</tr>
</tbody>
</table>
<p>文件映射页：指该页映射了文件的某一部分，比如基于文件内存映射的用户态地址空间中的所有页都是映射页，页高速缓存中的页也都是映射页。映射页差不多都是可同步的，可回收的。</p>
<p>匿名映射页： 指属于某一进程的某个匿名线性区，匿名线性区是指该线性区没有与之对应的文件，比如用户态的堆和栈都为匿名线性区，为回收页框， 内核必须将页中内容保存到一个专门的磁盘分区或磁盘文件，叫做“交换区“．因此，所有匿名页都是可交换的．</p>
<h3><span id="反向映射">反向映射</span></h3>
<p>page结构体使用mapping和index两个域进行反向映射</p>
<p>mapping指向address_space或者anon_vma或者空(交换高速缓存)，index表示偏移量</p>
<p>结合pte和index可以找到页表项</p>
<h4><span id="文件映射反向映射">文件映射反向映射</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/file-page-remap.png?raw=true" alt></p>
<p>address_space-&gt;i_mmap是个radix优先搜索树PST，PST的主要作用是执行反向映射vm_area_struct，当多个进程的线性区映射相同文件的相同部分，叶子节点是一个双向链表</p>
<p>address_sapce-&gt;i_mmap_nonlinear存放一个双向链表，成员是非线性映射的vm_area_struct</p>
<h4><span id="匿名映射反向映射">匿名映射反向映射</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/anonymous-page-remap.png?raw=true" alt></p>
<h3><span id="lru链表">LRU链表</span></h3>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/zone-list.jpg?raw=true" alt></p>
<p>Linux内核为每一片物理内存区域(zone)维护active_list 和inactive_list两个双向 链表，这两个list主要用来实现物理内存的回收。这两个链表上除了文件Cache之外，还包括其它匿名(Anonymous)内存，如进程堆栈等</p>
<h3><span id="交换">交换</span></h3>
<h4><span id="交换页">交换页</span></h4>
<p>交换用来为匿名页在磁盘上提供备份，有三类页必须由交换子系统处理：</p>
<ol>
<li>属于进程匿名线性区</li>
<li>属于进程私有文件映射的脏页(非脏页同步磁盘即可)</li>
<li>属于IPC共享内存区的页</li>
</ol>
<h4><span id="交换系统功能">交换系统功能</span></h4>
<p>交换子系统功能：</p>
<ol>
<li>磁盘上建立交换区，用于存放没有磁盘映像的页</li>
<li>管理交换区空间</li>
<li>提供函数用于页的换入换出</li>
<li>利用页表项中的换出页标识符跟踪数据在交换区的位置</li>
</ol>
<h4><span id="交换区描述符">交换区描述符</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/swap-area-data-structure.png?raw=true" alt></p>
<p>每个交换区由一组页槽page slot组成，第一页槽永久存放有关交换区的信息，union swap_header</p>
<p>每个活动的交换区在内存中都有自己的swap_info_struct描述符</p>
<p>swap_map是一个计数器数组，表示共享换出页的进程数</p>
<h4><span id="换出页标识符">换出页标识符</span></h4>
<p><img src="https://github.com/SoaringhawkCheng/blog/blob/master/source/_posts/design-of-linux-kernel/swap-page-identifier.png?raw=true" alt></p>
<p>当页被换出是，其标识符就作为页表项插入页表中，进程根据虚拟地址去页表查：</p>
<ol>
<li>空项 不属于进程的地址空间，或未分配页框</li>
<li>前31个最高位不全等于0，最后一位是0 页已换出</li>
<li>最低位是1 页在内存中</li>
</ol>
<h4><span id="交换高速缓存">交换高速缓存</span></h4>
<p>交换高速缓存由页高速缓存实现的</p>
<p>交换高速缓存的所有页只使用一个swapper_space地址空间，因此只有一个基数</p>
<p>swapper_space.page_tree对交换高速缓存中的页进行寻址</p>
<h2><span id="进程间通信">进程间通信</span></h2>
<p>进程间通信基本机制：</p>
<ol>
<li>管道和FIFO</li>
<li>信号量</li>
<li>消息</li>
<li>共享内存区</li>
<li>套接字</li>
</ol>
<h3><span id="管道">管道</span></h3>
<p>使用pipe创建一个管道，对于每个管道，内核都要创建一个索引节点对象和两个文件对象，一个文件读一个写</p>
<p>Linux使用pipefs特殊文件系统来实现管道，这种系统在系统目录树没有安装点</p>
<p>FIFO索引节点出现在系统目录树上，是双向通信</p>
<h2><span id="设备与模块">设备与模块</span></h2>
<h2><span id="调试">调试</span></h2>
<h2><span id="可移植性">可移植性</span></h2>
<h2><span id="补丁-开发和社区">补丁、开发和社区</span></h2>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/工程/design-of-redis/" data-toggle="tooltip" data-placement="top" title="「Redis设计与实现」学习笔记">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/工程/illustration-of-tcp-ip/" data-toggle="tooltip" data-placement="top" title="「图解TCP/IP」学习笔记">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">绪论</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">内核结构</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">特性</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">单内核微内核</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">Linux内核特性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">内核开发的准备</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">内存寻址</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">用户空间和内核空间</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">地址空间划分</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">地址映射模型</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">进程执行状态</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">上下文</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">CPU状态</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">进程上下文</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">中断上下文</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">进程管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">进程结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">进程任务队列</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">进程描述符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.3.</span> <span class="toc-nav-text">描述符存放</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.4.</span> <span class="toc-nav-text">进程状态</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.5.</span> <span class="toc-nav-text">进程家族树</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">进程创建</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.2.1.</span> <span class="toc-nav-text">fork</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.2.2.</span> <span class="toc-nav-text">vfork</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.2.3.</span> <span class="toc-nav-text">exec</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">线程在Linux中的实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.3.1.</span> <span class="toc-nav-text">创建线程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.3.2.</span> <span class="toc-nav-text">内核线程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">进程终结</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.4.1.</span> <span class="toc-nav-text">孤儿进程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">进程调度</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">多任务</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.1.1.</span> <span class="toc-nav-text">抢占式多任务</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.1.2.</span> <span class="toc-nav-text">非抢占式多任务</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">调度策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text">IO密集和CPU密集型进程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.2.2.</span> <span class="toc-nav-text">进程优先级</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.2.3.</span> <span class="toc-nav-text">时间片</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">调度算法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.3.1.</span> <span class="toc-nav-text">公平调度</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.3.2.</span> <span class="toc-nav-text">实时调度</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">调度实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.4.1.</span> <span class="toc-nav-text">时间记账</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.4.2.</span> <span class="toc-nav-text">算法步骤</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.4.3.</span> <span class="toc-nav-text">进程管理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text">抢占和上下文切换</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.5.1.</span> <span class="toc-nav-text">用户抢占</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">4.5.2.</span> <span class="toc-nav-text">内核抢占</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">系统调用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">意义</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">内核数据结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">中断和中断处理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">中断下半部</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">内核同步介绍</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">定时器和时间管理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">内存管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">内存管理结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.1.1.</span> <span class="toc-nav-text">内存管理单位</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.1.2.</span> <span class="toc-nav-text">物理内存分区</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.1.3.</span> <span class="toc-nav-text">内存分区介绍</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">11.2.</span> <span class="toc-nav-text">内核地址空间</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.2.1.</span> <span class="toc-nav-text">直接映射空间(PAGE_OFFSET~VMALLOC_START)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.2.2.</span> <span class="toc-nav-text">动态映射空间(VMALLOC_START~VMALLOC_END)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.2.3.</span> <span class="toc-nav-text">永久映射空间(PKMAP_BASE~FIXADDR_START)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.2.4.</span> <span class="toc-nav-text">临时映射空间(FIXADDR_START~FIXADDR_TOP)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">11.3.</span> <span class="toc-nav-text">进程地址空间</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">11.4.</span> <span class="toc-nav-text">内存分配系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.4.1.</span> <span class="toc-nav-text">伙伴系统(页分配)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.4.2.</span> <span class="toc-nav-text">slab分配层</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">11.5.</span> <span class="toc-nav-text">内存分配方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.5.1.</span> <span class="toc-nav-text">kmalloc</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.5.2.</span> <span class="toc-nav-text">vmalloc</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.5.3.</span> <span class="toc-nav-text">kmap</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">11.6.</span> <span class="toc-nav-text">内存分配维度</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.6.1.</span> <span class="toc-nav-text">按进程分配</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">11.6.2.</span> <span class="toc-nav-text">按CPU数据分配</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">虚拟文件系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">12.1.</span> <span class="toc-nav-text">文件系统抽象层</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">12.2.</span> <span class="toc-nav-text">UNIX文件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">12.3.</span> <span class="toc-nav-text">VFS对象和数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.3.1.</span> <span class="toc-nav-text">超级块对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.3.2.</span> <span class="toc-nav-text">索引节点对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.3.3.</span> <span class="toc-nav-text">目录项对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.3.4.</span> <span class="toc-nav-text">文件对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.3.5.</span> <span class="toc-nav-text">文件系统相关数据结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.3.6.</span> <span class="toc-nav-text">进程相关数据结构</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">12.4.</span> <span class="toc-nav-text">文件系统结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.4.1.</span> <span class="toc-nav-text">磁盘结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.4.2.</span> <span class="toc-nav-text">三级间接寻址</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.4.3.</span> <span class="toc-nav-text">数据块存储内容</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.4.4.</span> <span class="toc-nav-text">普通文件结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">12.4.5.</span> <span class="toc-nav-text">目录文件结构</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">块I&#x2F;O层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">13.1.</span> <span class="toc-nav-text">块设备简介</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">13.1.1.</span> <span class="toc-nav-text">扇区</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">13.1.2.</span> <span class="toc-nav-text">块</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">13.2.</span> <span class="toc-nav-text">内核访问块设备方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">13.2.1.</span> <span class="toc-nav-text">缓冲区buffer cache</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">13.2.2.</span> <span class="toc-nav-text">bio</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">13.3.</span> <span class="toc-nav-text">IO调度</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">进程地址空间</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">14.1.</span> <span class="toc-nav-text">内存描述符</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">14.1.1.</span> <span class="toc-nav-text">分配内存描述符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">14.1.2.</span> <span class="toc-nav-text">撤销内存描述符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">14.1.3.</span> <span class="toc-nav-text">内核线程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">14.2.</span> <span class="toc-nav-text">虚拟内存区域</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">14.3.</span> <span class="toc-nav-text">内存映射</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">14.3.1.</span> <span class="toc-nav-text">文件映射</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">14.3.2.</span> <span class="toc-nav-text">匿名映射</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">14.4.</span> <span class="toc-nav-text">页表</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">页高速缓存</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">15.1.</span> <span class="toc-nav-text">缓存页类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">15.2.</span> <span class="toc-nav-text">磁盘IO方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">15.2.1.</span> <span class="toc-nav-text">标准IO</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">15.2.2.</span> <span class="toc-nav-text">直接IO</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">15.2.3.</span> <span class="toc-nav-text">文件映射</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">15.3.</span> <span class="toc-nav-text">address_space对象</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">15.4.</span> <span class="toc-nav-text">写缓存策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">15.4.1.</span> <span class="toc-nav-text">缓存回收策略</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">页框回收</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">16.1.</span> <span class="toc-nav-text">页分类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">16.2.</span> <span class="toc-nav-text">反向映射</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.2.1.</span> <span class="toc-nav-text">文件映射反向映射</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.2.2.</span> <span class="toc-nav-text">匿名映射反向映射</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">16.3.</span> <span class="toc-nav-text">LRU链表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">16.4.</span> <span class="toc-nav-text">交换</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.4.1.</span> <span class="toc-nav-text">交换页</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.4.2.</span> <span class="toc-nav-text">交换系统功能</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.4.3.</span> <span class="toc-nav-text">交换区描述符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.4.4.</span> <span class="toc-nav-text">换出页标识符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">16.4.5.</span> <span class="toc-nav-text">交换高速缓存</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">进程间通信</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">17.1.</span> <span class="toc-nav-text">管道</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">设备与模块</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">19.</span> <span class="toc-nav-text">调试</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">20.</span> <span class="toc-nav-text">可移植性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">21.</span> <span class="toc-nav-text">补丁、开发和社区</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#os" title="os">os</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 
                    2021 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    追寻梦之碎片 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://blog.soaringhawkcheng.tech/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://blog.soaringhawkcheng.tech/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
